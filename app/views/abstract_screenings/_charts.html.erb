<script src="/echarts.min.js"></script>

<div class="flex flex-wrap" x-data="screening_charts">
  <div class="w-full lg:w-1/2 p-1 flex flex-col items-center justify-start">
    <div class="h-32 w-full" id="rejected-donut"></div>
    <div class="h-48 w-full" id="rejected-barchart"></div>
    <div
      class="text-xs"
      x-text="labeled_ml_data[ml_data_index]?.timestamp"
    ></div>
    <input
      class="w-full accent-srdrpurple cursor-pointer"
      type="range"
      min="0"
      :max="labeled_ml_data.length - 1"
      step="1"
      x-model="ml_data_index"
      @change="renderCharts()"
      @input="renderCharts()"
    />
  </div>
  <div class="w-full lg:w-1/2 p-1 flex flex-col items-center justify-start">
    <div class="h-32 w-full" id="accepted-donut"></div>
    <div class="h-48 w-full" id="accepted-barchart"></div>
    <div
      class="text-xs"
      x-text="labeled_ml_data[ml_data_index]?.timestamp"
    ></div>
    <input
      class="w-full accent-srdrpurple cursor-pointer"
      type="range"
      min="0"
      :max="labeled_ml_data.length - 1"
      step="1"
      x-model="ml_data_index"
      @change="renderCharts()"
      @input="renderCharts()"
    />
  </div>
  <div
    class="w-full lg:w-1/2 p-1 bg-purple-50 flex flex-col items-center justify-start rounded-md"
  >
    <div class="h-32 w-full" id="labels-donut"></div>
    <div class="h-48 w-full" id="labels-barchart"></div>
    <div class="p-1 w-full flex items-center justify-around">
      <input
        type="number"
        class="!text-xs !w-1/3 !bg-transparent text-center"
        x-model="currentMinCertainty"
        @change="await $nextTick();
        if (currentMinCertainty == '') {
          currentMinCertainty = oldMinCertainty;
        }
        if (currentMinCertainty < 0) {
          currentMinCertainty = 0;
        }
        if (currentMinCertainty >= currentMaxCertainty) {
          currentMinCertainty = currentMaxCertainty - 1;
        }
        barChart('labels-barchart', null);"
      />
      <div>to</div>
      <input
        type="number"
        class="!text-xs !w-1/3 !bg-transparent text-center"
        x-model="currentMaxCertainty"
        @change="await $nextTick();
        if (currentMaxCertainty == '') {
          currentMaxCertainty = oldMaxCertainty
        }
        if (currentMaxCertainty > 100) {
          currentMaxCertainty = 100;
        }
        if (currentMaxCertainty <= currentMinCertainty) {
          currentMaxCertainty = currentMinCertainty + 1;
        }
        barChart('labels-barchart', null);"
      />
    </div>
    <div
      class="text-xs p-1 w-full flex items-center justify-center text-black-700 font-bold"
    >
      % Certainty
    </div>
  </div>
  <div class="w-full lg:w-1/2 p-1 flex flex-col items-center justify-start">
    <table class="h-full text-center">
      <tbody>
        <tr>
          <td class="text-xs font-bold align-middle" rowspan="2"></td>
          <td class="text-xs font-bold align-middle"></td>
          <td
            class="text-xs font-bold align-middle"
            colspan="2"
            style="background: #bbeeee"
          >
            Predicted condition
          </td>
        </tr>
        <tr>
          <td class="text-xs font-bold align-middle bg-gray-200">
            Total population = P + N
          </td>
          <td class="text-xs font-bold align-middle bg-teal-100">
            Positive (PP)
          </td>
          <td class="text-xs font-bold align-middle bg-teal-200">
            Negative (PN)
          </td>
        </tr>
        <tr>
          <td
            class="text-xs font-bold align-middle"
            rowspan="2"
            style="
              vertical-align: middle;
              padding: 0.4em 0.4em 0.2em;
              background-position: 50% 0.4em !important;
              min-width: 0.875em;
              max-width: 0.875em;
              overflow: hidden;
              background: #eeeebb;
            "
          >
            <div
              style="
                -o-writing-mode: vertical-rl;
                -ms-writing-mode: tb-rl;
                writing-mode: tb-rl;
                writing-mode: vertical-rl;
                transform: rotate(180deg);
                display: inline-block;
                padding-left: 1px;
                text-align: center;
              "
            >
              Actual condition
            </div>
          </td>
          <td class="text-xs font-bold align-middle bg-amber-100">
            Positive (P)
          </td>
          <td class="text-xs font-bold align-middle bg-green-100">
            <div
              x-text="labeled_ml_data[ml_data_index]?.confusion_matrix?.TP"
            ></div>
          </td>
          <td class="text-xs font-bold align-middle bg-red-100">
            <div
              x-text="labeled_ml_data[ml_data_index]?.confusion_matrix?.FN"
            ></div>
          </td>
        </tr>
        <tr>
          <td class="text-xs font-bold align-middle bg-amber-200">
            Negative (N) #
          </td>
          <td class="text-xs font-bold align-middle bg-red-200">
            <div
              x-text="labeled_ml_data[ml_data_index]?.confusion_matrix?.FP"
            ></div>
          </td>
          <td class="text-xs font-bold align-middle bg-green-200">
            <div
              x-text="labeled_ml_data[ml_data_index]?.confusion_matrix?.TN"
            ></div>
          </td>
        </tr>
      </tbody>
    </table>
    <div class="w-full grid grid-cols-2 text-xs">
      <div class="border">
        Accuracy Score:
        <span x-text="labeled_ml_data[ml_data_index]?.accuracy_score"></span>
      </div>
      <div class="border">
        F1 Score:
        <span x-text="labeled_ml_data[ml_data_index]?.f1_score"></span>
      </div>
      <div class="border">
        Precision:
        <span x-text="labeled_ml_data[ml_data_index]?.precision"></span>
      </div>
      <div class="border">
        Recall:
        <span x-text="labeled_ml_data[ml_data_index]?.recall"></span>
      </div>
    </div>
  </div>
</div>
<script>
  document.addEventListener("alpine:init", () => {
    Alpine.data("screening_charts", () => ({
      oldMinCertainty: 30,
      oldMaxCertainty: 70,
      currentMinCertainty: 30,
      currentMaxCertainty: 70,
      ml_model_timestamps: [],
      ml_data_index: 0,
      labeled_ml_data: [],
      unlabeled_ml_data: {},

      async init() {
        await this.fetchUnlabeledMlData();
        await this.fetchLabeledMlData();
        this.renderCharts();
      },

      async fetchUnlabeledMlData() {
        const response = await fetch(
          "/projects/<%= params[:id] %>/unlabeled_predictions",
          {
            method: "GET",
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json",
            },
          }
        );
        const data = await response.json();
        this.unlabeled_ml_data = data;
      },

      async fetchLabeledMlData() {
        const response = await fetch(
          "/model_performances/by_project/<%= params[:id] %>",
          {
            method: "GET",
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json",
            },
          }
        );
        const data = await response.json();
        this.labeled_ml_data = data;
        for (let i; i < this.labeled_ml_data.length; i++) {
          const project_ml_datum = this.labeled_ml_data[i];
          this.ml_model_timestamps.push(project_ml_datum.timestamp);
        }
        this.ml_data_index = data.length - 1;
      },

      renderCharts() {
        this.donutChart("rejected-donut");
        this.donutChart("accepted-donut");
        this.donutChart("labels-donut");
        this.barChart("rejected-barchart", 0);
        this.barChart("accepted-barchart", 1);
        this.barChart("labels-barchart", null);
      },

      donutChart(id) {
        const myChart = echarts.init(document.getElementById(id), null, {
          renderer: "svg",
        });
        const option = {
          grid: {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0,
          },
          tooltip: {
            trigger: "item",
          },
          series: [
            {
              type: "pie",
              radius: ["40%", "70%"],
              avoidLabelOverlap: false,
              labelLine: {
                show: false,
              },
              label: {
                show: false,
              },
              data: [],
            },
          ],
        };
        const data = [];
        data.push({
          value:
            this.labeled_ml_data[this.ml_data_index]?.performances[0].length,
          name: "Rejected",
          itemStyle: {
            color: `rgba(150, 0, 0, ${id.includes("rejected") ? 1 : 0.2})`,
          },
        });

        data.push({
          value:
            this.labeled_ml_data[this.ml_data_index]?.performances[1].length,
          name: "Accepted",
          itemStyle: {
            color: `rgba(0, 100, 0, ${id.includes("accepted") ? 1 : 0.2})`,
          },
        });

        data.push({
          value: Object.values(this.unlabeled_ml_data).reduce(
            (acc, v) => acc + v
          ),
          name: "Unlabeled",
          itemStyle: {
            color: `rgba(100, 100, 100, ${id.includes("labels") ? 1 : 0.2})`,
          },
        });

        option.series[0].data = data;

        option && myChart.setOption(option);
        window.addEventListener("resize", () => myChart.resize());
      },

      calculateBuckets(id, key) {
        const data = [];
        const axisKeys = this.barAxisData();

        if (key === null) {
          for (let i = 0; i < 10; i++) {
            const bucketThreshold = 10 * i;
            if (
              bucketThreshold >= this.currentMinCertainty &&
              bucketThreshold < this.currentMaxCertainty
            ) {
              color = "rgba(100, 100, 100, 1)";
            } else if (bucketThreshold < this.currentMinCertainty) {
              color = "rgba(150, 0, 0, 1)";
            } else {
              color = "rgba(0, 100, 0, 1)";
            }
            data.push({
              value: this.unlabeled_ml_data[axisKeys[i]],
              itemStyle: { color },
            });
          }
          return data;
        }

        const values =
          this.labeled_ml_data[this.ml_data_index]?.performances[key];
        const bucketHash = {};
        for (
          let bucketThreshold = 0;
          bucketThreshold < 100;
          bucketThreshold += 10
        ) {
          bucketHash[bucketThreshold] = 0;
          for (let ii = 0; ii < values.length; ii++) {
            const normalizedValue = Math.round(values[ii] * 100);
            if (
              normalizedValue >= bucketThreshold &&
              normalizedValue < bucketThreshold + 10
            ) {
              bucketHash[bucketThreshold] = bucketHash[bucketThreshold] + 1;
            }
          }
        }

        for (let i = 0; i < 100; i += 10) {
          let color;
          if (id.includes("accepted")) {
            color = "rgba(0, 100, 0, 1)";
          } else if (id.includes("rejected")) {
            color = "rgba(150, 0, 0, 1)";
          }
          data.push({
            value: bucketHash[i],
            itemStyle: { color },
          });
        }

        return data;
      },

      barAxisData() {
        return [
          "0.0-0.1",
          "0.1-0.2",
          "0.2-0.3",
          "0.3-0.4",
          "0.4-0.5",
          "0.5-0.6",
          "0.6-0.7",
          "0.7-0.8",
          "0.8-0.9",
          "0.9-1.0",
        ];
      },

      barChart(id, key) {
        const myChart = echarts.init(document.getElementById(id), null, {
          renderer: "svg",
        });
        const option = {
          grid: {
            left: 50,
            top: 50,
            right: 50,
            bottom: 50,
          },
          tooltip: {},
          xAxis: {
            data: this.barAxisData(),
          },
          yAxis: {},
          series: [
            {
              name: "Labels",
              type: "bar",
              data: [],
            },
          ],
        };
        option.series[0].data = this.calculateBuckets(id, key);

        myChart.setOption(option);
        window.addEventListener("resize", () => myChart.resize());
      },
    }));
  });
</script>
