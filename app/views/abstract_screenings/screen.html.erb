<div
  x-data="screenStore"
  @keyup.escape.window="closeAllModals()"
  id="abstrackr-wrapper"
>
  <!-- prettier-ignore -->
  <%= render 'abstract_screenings/screen/weighing_screen' %>
  <%= render 'abstract_screenings/screen/word_weight_menu' %>
  <%= render 'abstract_screenings/screen/confirmation_modal' %>
  <%= render 'abstract_screenings/screen/reasoning_menu' %>
  <%= render 'abstract_screenings/screen/add_reasoning' %>
  <div
    class="m-auto lg:w-1/2 h-32 absolute inset-0 mt-0 overflow-y-hidden bg-gray-300 flex flex-col justify-center"
  >
    <a
      href="<%= abstract_screening_path(params[:abstract_screening_id]) %>"
      class="cursor-pointer z-[5] absolute top-4 right-4 bg-gray-100 rounded-md p-2 inline-flex items-center justify-center text-gray-400 hover:text-gray-500 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500"
    >
      <span class="sr-only">Close menu</span>
      <!-- Heroicon name: outline/x -->
      <svg
        class="h-6 w-6"
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
        aria-hidden="true"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M6 18L18 6M6 6l12 12"
        />
      </svg>
    </a>
    <button
      type="button"
      class="cursor-pointer z-[5] absolute top-16 right-4 bg-gray-100 rounded-md p-2 inline-flex items-center justify-center text-gray-400 hover:text-gray-500 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500"
      @click="word_weight_menu = !word_weight_menu"
    >
      <span class="sr-only">Word weights</span>
      <!-- Heroicon name: outline/x -->
      <svg
        xmlns="http://www.w3.org/2000/svg"
        class="h-6 w-6"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
        stroke-width="2"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
        />
      </svg>
    </button>
    <a
      x-bind:href="`/abstract_screenings/${citation.abstract_screening_id}/rescreen?abstract_screening_result_id=${rescreen}&previous=true`"
      class="cursor-pointer z-[5] absolute top-4 right-16 bg-gray-100 rounded-md p-2 inline-flex items-center justify-center text-gray-400 hover:text-gray-500 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        class="h-6 w-6"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
        stroke-width="2"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          d="M12.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0019 16V8a1 1 0 00-1.6-.8l-5.333 4zM4.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0011 16V8a1 1 0 00-1.6-.8l-5.334 4z"
        />
      </svg>
    </a>
    <div class="mt-3">
      <div
        class="horizontal-scroll-wrapper"
        @mouseup="checkSelection()"
        @touchend="checkSelection()"
      >
        <h1 class="px-8 text-base font-bold">
          <template x-for="word in processedTitle">
            <span
              class="cursor-pointer hover:bg-yellow-200"
              x-text="word.text"
              @click="weighWord(word.text)"
              :class="cssWordClass[word.weight]"
            ></span>
          </template>
        </h1>
      </div>
      <div class="px-8 text-sm overflow-x-auto whitespace-nowrap">
        Journal: <span x-text="citation.journal"></span>
      </div>
      <div class="horizontal-scroll-wrapper">
        <div
          class="horizontal-scroll-wrapper-item text-sm overflow-x-auto whitespace-nowrap"
        >
          Authors: <span x-text="citation.authors"></span>
        </div>
      </div>
    </div>
  </div>
  <div
    class="m-auto lg:w-1/2 h-auto block absolute inset-0 mt-32 mb-32 overflow-y-auto overflow-x-hidden bg-gray-100"
  >
    <div class="vertical-scroll-wrapper">
      <div class="vertical-scroll-wrapper-item">
        <div
          class="px-8 leading-loose"
          @mouseup="checkSelection()"
          @touchend="checkSelection()"
        >
          <template x-for="word in processedAbstract">
            <span
              class="cursor-pointer hover:bg-yellow-200"
              x-text="word.text"
              :class="cssWordClass[word.weight]"
              @click="weighWord(word.text)"
            ></span>
          </template>
        </div>
        <hr />
        <div
          class="px-8 break-all leading-loose"
          x-text="citation.keywords"
        ></div>
        <div class="px-8 break-all leading-loose" x-text="citation.id"></div>
      </div>
    </div>
  </div>

  <div
    class="lg:w-1/2 m-auto absolute bottom-0 left-0 right-0 bg-gray-100 h-32"
  >
    <div class="h-full text-white">
      <div class="grid grid-cols-3 h-full">
        <div
          class="cursor-pointer border-r-8 bg-red-500 flex justify-center items-center rounded-tl-2xl"
          @click="label_value = -1; if (requireReasoning()) { reasoningMenu = true } else { postLabel(true) }"
          :class="(label_value == -1 || label_value == null) ? '' : 'saturate-[0.1]'"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-10 w-10"
            viewBox="0 0 20 20"
            fill="currentColor"
          >
            <path
              fill-rule="evenodd"
              d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
              clip-rule="evenodd"
            />
          </svg>
        </div>
        <div class="grid grid-rows-2">
          <div
            class="cursor-pointer border-b-4 bg-srdrpurple flex justify-center items-center"
            @click="label_value = 0; if (requireReasoning()) { reasoningMenu = true } else { postLabel(true) }"
            :class="(label_value == 0 || label_value == null)? '' : 'saturate-[0.1]'"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-10 w-10"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              stroke-width="2"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
              />
            </svg>
          </div>
          <div
            class="cursor-pointer border-t-2 bg-gray-500 flex justify-center items-center"
            @click="label_value = null; reasoningMenu = !reasoningMenu"
          >
            <div class="space-y-2">
              <div class="w-8 h-0.5 bg-white"></div>
              <div class="w-8 h-0.5 bg-white"></div>
              <div class="w-8 h-0.5 bg-white"></div>
            </div>
          </div>
        </div>
        <div
          class="cursor-pointer border-l-8 bg-green-500 flex justify-center items-center rounded-tr-2xl"
          @click="label_value = 1; if (requireReasoning()) { reasoningMenu = true } else { postLabel(true) }"
          :class="(label_value == 1 || label_value == null)? '' : 'saturate-[0.1]'"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-10 w-10"
            viewBox="0 0 20 20"
            fill="currentColor"
          >
            <path
              fill-rule="evenodd"
              d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
              clip-rule="evenodd"
            />
          </svg>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  document.addEventListener("alpine:init", () => {
    Alpine.data("screenStore", () => ({
      weighingScreen: false,
      word_weight_menu: false,
      reasoningMenu: false,
      addReasonModal: { on: false, type: "" },
      confirmationModalLabel: null,
      confirmationModal: false,
      confirmationModalText: "",
      confirmationModalTexts: {
        "-1": "Rejected",
        0: "Maybe",
        1: "Accepted",
      },
      loading: false,
      citation: {
        abstract_screening_id: "",
        abstract_screenings_citations_project_id: "",
        title: "",
        journal: "",
        authors: "",
        abstract: "",
        keywords: "",
        id: "",
      },
      abstract_screening_result_id: null,
      predefined_reasons: {},
      predefined_tags: {},
      custom_reasons: {},
      custom_tags: {},
      notes: "",
      options: {
        yes_tag_required: null,
        no_tag_required: null,
        maybe_tag_required: null,
        yes_reason_required: null,
        no_reason_required: null,
        maybe_reason_required: null,
        yes_note_required: null,
        no_note_required: null,
        maybe_note_required: null,
        only_predefined_reasons: null,
        only_predefined_tags: null,
      },
      label_value: null,
      word_weights: {},
      wordWeight: "",
      cssWordClass: {
        2: "text-green-500 font-black",
        1: "text-green-500",
        0: "",
        "-1": "text-red-500",
        "-2": "text-red-500 font-black",
      },
      textarea_keywords_and_phrases: "",
      newCustomValue: "",
      rescreen: null,
      processedTitle: [],
      processedAbstract: [],
      disable_textarea_keywords_and_phrases: false,

      init() {
        this.postLabel(false);
      },

      toggleWeighingScreen() {
        this.weighingScreen = !this.weighingScreen;
      },

      requireReasoning() {
        return (
          (this.label_value == -1 &&
            (this.options.no_tag_required ||
              this.options.no_reason_required ||
              this.options.no_note_required)) ||
          (this.label_value == 0 &&
            (this.options.maybe_tag_required ||
              this.options.maybe_reason_required ||
              this.options.maybe_note_required)) ||
          (this.label_value == 1 &&
            (this.options.yes_tag_required ||
              this.options.yes_reason_required ||
              this.options.yes_note_required))
        );
      },

      satisfiesReasoning() {
        if (this.label_value == null) return false;
        let satisfactory = true;
        const hasSomeReason = Object.keys({
          ...this.predefined_reasons,
          ...this.custom_reasons,
        }).some(
          (v) =>
            this.predefined_reasons[v] == true || this.custom_reasons[v] == true
        );
        const hasSomeTag = Object.keys({
          ...this.predefined_tags,
          ...this.custom_tags,
        }).some(
          (v) => this.predefined_tags[v] == true || this.custom_tags[v] == true
        );
        const hasSomeNote = this.notes.length > 0;
        if (this.label_value == -1) {
          if (this.options.no_tag_required)
            satisfactory = hasSomeTag && satisfactory;
          if (this.options.no_reason_required)
            satisfactory = hasSomeReason && satisfactory;
          if (this.options.no_note_required)
            satisfactory = hasSomeNote && satisfactory;
        }
        if (this.label_value == 0) {
          if (this.options.maybe_tag_required)
            satisfactory = hasSomeTag && satisfactory;
          if (this.options.maybe_reason_required)
            satisfactory = hasSomeReason && satisfactory;
          if (this.options.maybe_note_required)
            satisfactory = hasSomeNote && satisfactory;
        }
        if (this.label_value == 1) {
          if (this.options.yes_tag_required)
            satisfactory = hasSomeTag && satisfactory;
          if (this.options.yes_reason_required)
            satisfactory = hasSomeReason && satisfactory;
          if (this.options.yes_note_required)
            satisfactory = hasSomeNote && satisfactory;
        }

        return satisfactory;
      },

      mustSelectReason() {
        if (this.label_value == -1) {
          return this.options.no_reason_required;
        } else if (this.label_value == 0) {
          return this.options.maybe_reason_required;
        } else if (this.label_value == 1) {
          return this.options.yes_reason_required;
        }
      },

      mustSelectTag() {
        if (this.label_value == -1) {
          return this.options.no_tag_required;
        } else if (this.label_value == 0) {
          return this.options.maybe_tag_required;
        } else if (this.label_value == 1) {
          return this.options.yes_tag_required;
        }
      },

      mustEnterNotes() {
        if (this.label_value == -1) {
          return this.options.no_note_required;
        } else if (this.label_value == 0) {
          return this.options.maybe_note_required;
        } else if (this.label_value == 1) {
          return this.options.yes_note_required;
        }
      },

      turnOffAllReasons() {
        Object.keys(this.predefined_reasons).forEach(
          (v) => (this.predefined_reasons[v] = false)
        );
        Object.keys(this.custom_reasons).forEach(
          (v) => (this.custom_reasons[v] = false)
        );
      },

      processNewCustomValue() {
        if (this.newCustomValue.trim() == "") return;
        this.addReasonModal.on = false;
        if (this.addReasonModal.type == "Reason") {
          this.turnOffAllReasons();
          if (this.predefined_reasons[this.newCustomValue] == undefined) {
            this.custom_reasons[this.newCustomValue] = true;
          } else {
            this.predefined_reasons[this.newCustomValue] = true;
          }
        } else {
          if (this.predefined_tags[this.newCustomValue] == undefined) {
            this.custom_tags[this.newCustomValue] = true;
          } else {
            this.predefined_tags[this.newCustomValue] = true;
          }
        }
        this.newCustomValue = "";
        this.postLabel(false);
      },

      deleteCustomValue(type, key) {
        if (confirm(`Would you like to delete "${key}" as a custom choice?`)) {
          delete this[type][key];
        }
      },

      closeAllModals() {
        if (this.addReasonModal.on) {
          this.addReasonModal.on = false;
        } else {
          this.weighingScreen = false;
          this.reasoningMenu = false;
          this.word_weight_menu = false;
        }
      },

      checkSelection() {
        const selection = window.getSelection().toString();
        this.weighWord(selection);
      },

      update_word_weight(event, id, weight) {
        const word = event.target.value;

        if (
          word.length == 0 ||
          (word in this.word_weights && this.word_weights[word].id != id)
        ) {
          event.target.classList.add("!bg-red-500");
          return;
        } else {
          event.target.classList.remove("!bg-red-500");
        }
        this.sendWw(word, weight, id);
        setTimeout(() => this.$focus.focus(event.target), 500);
      },

      weighWord(word) {
        if (word.length > 0 && word != " ") {
          this.weighingScreen = true;
          this.wordWeight = word;
          this.$nextTick(() => {
            this.$refs.wordWeightInput.focus();
          });
        }
      },

      checkLengthRestriction(event, maxLength) {
        if (event.target.value.length >= maxLength) {
          toastr.warning(`The input limit is ${maxLength}`);
        }
      },

      async process_textarea_keywords_and_phrases() {
        this.disable_textarea_keywords_and_phrases = true;
        const lines = this.textarea_keywords_and_phrases.split("\n");
        const unprocessable = [];
        for (const line of lines) {
          const lineParts = line.split(" ");
          const wordParts = lineParts.slice(0, -1);
          const weight = parseInt(lineParts.slice(-1));
          const word = wordParts.join(" ");
          if (
            word.length < 1 ||
            word.length > 50 ||
            weight === NaN ||
            [2, 1, 0, -1, -2].indexOf(weight) === -1
          ) {
            unprocessable.push(line);
            continue;
          }

          await this.sendWw(word, weight, null, weight === 0);
        }
        this.textarea_keywords_and_phrases = unprocessable.join("\n");
        this.disable_textarea_keywords_and_phrases = false;
        if (unprocessable.length > 0) {
          toastr.error("Some words or phrases could not be processed.");
        }
      },

      paste_textarea_keywords_and_phrases() {
        this.textarea_keywords_and_phrases = Object.keys(this.word_weights)
          .sort()
          .map((word) => {
            return word + " " + this.word_weights[word].weight;
          })
          .join("\n");
      },

      processWeights(sourceKey, destinationKey) {
        this[destinationKey] = [];
        let head = 0;
        let tail = 1;
        while (this.citation[sourceKey].length > head) {
          for (const word of Object.keys(this.word_weights)) {
            if (word.length == 0) continue;
            const candidate = this.citation[sourceKey].slice(
              head,
              head + word.length
            );
            lowerCaseCandidate = candidate.toLowerCase();
            if (lowerCaseCandidate in this.word_weights) {
              this[destinationKey].push({
                text: candidate,
                weight: this.word_weights[lowerCaseCandidate].weight,
              });
              head += word.length;
              tail = head + 1;
            }
          }
          const partial = this.citation[sourceKey].slice(head, tail);
          if (this.citation[sourceKey][tail] == undefined) {
            head += 1;
            tail = head + 1;
            continue;
          }
          if (tail - head == 1 && !partial.match(/[a-z]|[A-Z]/)) {
            this[destinationKey].push({ text: partial, weight: 0 });
            head += 1;
            tail = head + 1;
          } else if (!this.citation[sourceKey][tail].match(/[a-z]|[A-Z]/)) {
            if (partial in this.word_weights) {
              this[destinationKey].push({
                text: partial,
                weight: this.word_weights[partial].weight,
              });
            } else {
              this[destinationKey].push({
                text: partial,
                weight: 0,
              });
            }
            head += partial.length;
            tail = head + 1;
          } else {
            tail += 1;
          }
        }
      },

      async awaitLoading(cb) {
        if (this.loading) {
          await new Promise((resolve, reject) => setTimeout(resolve, 50));
          this.awaitLoading(cb);
        } else {
          cb();
        }
      },

      showConfirmation(label) {
        this.confirmationModalLabel = label;
        this.confirmationModalText = this.confirmationModalTexts[label];
        this.confirmationModal = true;
        setTimeout(
          () => this.awaitLoading(() => (this.confirmationModal = false)),
          1000
        );
      },

      async sendWw(word, weight, id, destroy) {
        const response = await fetch(
          "/abstract_screenings/<%= params[:abstract_screening_id] %>/update_word_weight",
          {
            method: "POST",
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              word,
              weight,
              id,
              destroy,
            }),
          }
        );
        const data = await response.json();
        this.word_weights = data;
        this.processWeights("title", "processedTitle");
        this.processWeights("abstract", "processedAbstract");
      },

      async postLabel(submit) {
        if (submit) {
          this.reasoningMenu = false;
          this.showConfirmation(this.label_value);
        }
        this.loading = true;
        const response = await fetch(
          "/abstract_screenings/<%= params[:abstract_screening_id] %>/label",
          {
            method: "POST",
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              data: {
                label_value: submit ? this.label_value : null,
                citation: this.citation,
                abstract_screening_result_id: this.abstract_screening_result_id,
                predefined_reasons: this.predefined_reasons,
                predefined_tags: this.predefined_tags,
                custom_reasons: this.custom_reasons,
                custom_tags: this.custom_tags,
                notes: this.notes,
                rescreen: this.rescreen,
              },
            }),
          }
        );
        const data = await response.json();
        if (data.noResults) {
          return (window.location.href =
            "<%= abstract_screening_path(params[:abstract_screening_id], screeningFinished: true) %>");
        }
        this.label_value = submit ? data.label_value : this.label_value;
        this.citation = data.citation;
        this.abstract_screening_result_id = data.abstract_screening_result_id;
        this.predefined_reasons = data.predefined_reasons;
        this.predefined_tags = data.predefined_tags;
        this.custom_reasons = data.custom_reasons;
        this.custom_tags = data.custom_tags;
        this.notes = data.notes;
        this.options = data.options;
        this.word_weights = data.word_weights;
        this.rescreen = data.rescreen;

        this.processWeights("title", "processedTitle");
        this.processWeights("abstract", "processedAbstract");
        this.loading = false;
      },
    }));
  });
</script>
